using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.CommandLineUtils;
using System.Reflection;
using System.Runtime.Loader;
using System.IO;

namespace Umbrella.TypeScript.Tools
{
    public class Program
    {
        public static int Main(string[] args)
        {
            var app = new CommandLineApplication
            {
                Name = "dotnet-umbrella-typescript",
                FullName = ".NET Core Umbrella TypeScript Generator",
                Description = "TypeScript generator for .NET Core applications",
            };
            app.HelpOption("-?|-h|--help");

            CommandOption coAssemblyFolderPath = app.Option("--input|-i", "The physical path to the folder containing the assemblies to scan for TypeScript attributes.", CommandOptionType.SingleValue);
            CommandOption coAssemblyNames = app.Option("--assemblies|-a", "The names of the assemblies to scan for attributes. If not supplied all assemblies in the folder path will be scanned.", CommandOptionType.MultipleValue);
            CommandOption coGenerators = app.Option("--generators|-g", "The generators to include: [standard | knockout]", CommandOptionType.MultipleValue);
            CommandOption coOutputType = app.Option("--type|-t", "The output type: [namespace, module]", CommandOptionType.SingleValue);
            CommandOption coStrictNullChecks = app.Option("--strict|-s", "Enable strict null checks", CommandOptionType.NoValue);
            CommandOption coPropertyMode = app.Option("--mode|-m", "The TypeScriptPropertyMode to use: [none, null, model]", CommandOptionType.SingleValue);
            CommandOption coOuputPath = app.Option("--ouput|-o", "The path where the output file will be written.", CommandOptionType.SingleValue);

            app.OnExecute(() =>
            {
                string assemblyFolderPath = coAssemblyFolderPath.Value();
                List<string> assemblyNames = coAssemblyNames.Values;
                List<string> generators = coGenerators.Values;
                string outputType = coOutputType.Value();
                bool strictNullChecks = coStrictNullChecks.HasValue();
                string propertyMode = coPropertyMode.Value();
                string outputPath = coOuputPath.Value();

                //TODO: Show help if not all required args specified

                if (!Enum.TryParse(propertyMode, out TypeScriptPropertyMode tsPropertyMode))
                {
                    //TODO: show error
                }

                //Check folder exists
                if (!Directory.Exists(assemblyFolderPath))
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine($"The path for the --input|-i argument {assemblyFolderPath} does not exist.");
                    return 3;
                }

                List<Assembly> lstAssemblyToProcess = new List<Assembly>();

                foreach (var fileName in Directory.EnumerateFiles(assemblyFolderPath, "*.dll"))
                {
                    if (assemblyNames.Count > 0)
                    {
                        if (!assemblyNames.Contains(Path.GetFileNameWithoutExtension(fileName)))
                            continue;
                    }

                    using (FileStream fs = File.OpenRead(fileName))
                    {
                        Assembly assembly = AssemblyLoadContext.Default.LoadFromStream(fs);

                        lstAssemblyToProcess.Add(assembly);
                    }
                }

                if (lstAssemblyToProcess.Count == 0)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine($"No assemblies were loaded to process.");
                    return 3;
                }

                var generator = new TypeScriptGenerator(lstAssemblyToProcess);

                if (generators.Contains("standard"))
                    generator.IncludeStandardGenerators();

                if (generators.Contains("knockout"))
                    generator.IncludeKnockoutGenerators();

                string strOutput = generator.GenerateAll(outputType == "module", strictNullChecks, tsPropertyMode);

                StringBuilder sbOutput = new StringBuilder()
                    .AppendLine("//------------------------------------------------------------------------------")
                    .AppendLine("// <auto-generated>")
                    .AppendLine("//")
                    .AppendLine("// This code has been automatically generated by a tool. Any changes made to")
                    .AppendLine("// this file will be overwritten the next time the tool is run.")
                    .AppendLine("//")
                    .AppendLine("// </auto-generated>")
                    .AppendLine("//------------------------------------------------------------------------------");

                sbOutput.AppendLine(strOutput);

                using (StreamWriter sw = File.CreateText(outputPath))
                {
                    sw.Write(sbOutput.ToString());
                }

                return 0;
            });

            if (args == null ||
                args.Length == 0 ||
                args[0].Equals("-?", StringComparison.OrdinalIgnoreCase) ||
                args[0].Equals("-h", StringComparison.OrdinalIgnoreCase) ||
                args[0].Equals("--help", StringComparison.OrdinalIgnoreCase))
            {
                app.ShowHelp();
                return 1;
            }

            try
            {
                return app.Execute(args);
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("Failed: " + ex.Message);
                return 1;
            }
        }
    }
}